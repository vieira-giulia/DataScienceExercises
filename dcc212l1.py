#!/usr/bin/env python
# coding: utf-8

# # Lista 01 - Introdu√ß√£o e Revis√£o Numpy
# 
# [NumPy](http://numpy.org) √© um pacote incrivelmente poderoso em Python, onipresente em qualquer projeto de ci√™ncia de dados. Possui forte integra√ß√£o com o [Pandas](http://pandas.pydata.org), outra ferramenta que iremos abordar na mat√©ria. NumPy adiciona suporte para matrizes multidimensionais e fun√ß√µes matem√°ticas que permitem que voc√™ execute facilmente c√°lculos de √°lgebra linear. Este notebook ser√° uma cole√ß√£o de exemplos de √°lgebra linear computados usando NumPy. 
# 
# ## Numpy 
# 
# Para fazer uso de Numpy precisamos importar a biblioteca

# In[2]:


# -*- coding: utf8

import numpy as np


# Quando pensamos no lado pr√°tico de ci√™ncia de dados, um aspecto chave que ajuda na implementa√ß√£o de novos algoritmos √© a vetoriza√ß√£o. De forma simples, vetoriza√ß√£o consiste do uso de tipos como **escalar**, **vetor** e **matriz** para realizar uma computa√ß√£o mais eficaz (em tempo de execu√ß√£o).
# 
# Uma matriz √© uma cole√ß√£o de valores, normalmente representada por uma grade ùëö √ó ùëõ, onde ùëö √© o n√∫mero de linhas e ùëõ √© o n√∫mero de colunas. Os comprimentos das arestas ùëö e ùëõ n√£o precisam ser necessariamente diferentes. Se tivermos ùëö = ùëõ, chamamos isso de matriz quadrada. Um caso particularmente interessante de uma matriz √© quando ùëö = 1 ou ùëõ = 1. Nesse caso, temos um caso especial de uma matriz que chamamos de vetor. Embora haja um objeto de matriz em NumPy, faremos tudo usando matrizes NumPy porque elas podem ter dimens√µes maiores que 2. 
# 
# 1. **Escalar:** Um vetor de zero dimens√µes

# In[3]:


1


# 2. **Vetor:** Representa uma dimens√£o

# Abaixo vamos criar um vetor simples. Inicialmente, vamos criar uma lista.

# In[4]:


data_list = [3.5, 5, 2, 8, 4.2]


# Observe o tipo da mesma.

# In[5]:


type(data_list)


# Embora vetores e listas sejam parecidos, vetores Numpy s√£o otimizados para opera√ß√µes de √Ålgebra Linear. Ci√™ncia de Dados faz bastante uso de tais opera√ß√µes, sendo este um dos motivos da depend√™ncia em Numpy.
# 
# Abaixo criamos um vetor.

# In[6]:


data = np.array(data_list)
print(data)
print(type(data))


# Observe como podemos somar o mesmo com um n√∫mero. N√£o √© poss√≠vel fazer tal opera√ß√£o com listas.

# In[7]:


data + 7


# 3. **Matrizes:** Representam duas dimens√µes.

# In[8]:


X = np.array([[2, 4],
              [1, 3]])
X


# Podemos indexar as matrizes e os vetores.

# In[9]:


data[0]


# In[10]:


X[0, 1] # aqui √© primeira linha, segunda coluna


# Podemos tamb√©m criar vetores/matrizes de n√∫meros aleat√≥rios

# In[11]:


X = np.random.randn(4, 3) # Gera n√∫meros aleat√≥rios de uma normal
print(X)


# ### Indexando
# 
# Pegando a primeira linha

# In[12]:


X[0] # observe que 0 √© a linha 1, compare com o X[0, 1] de antes.


# In[13]:


X[1] # segunda


# In[14]:


X[2] # terceira


# Observe como todos os tipos retornados s√£o `array`. Array √© o nome gen√©rico de Numpy para vetores e matrizes. 

# `X[:, c]` pega uma coluna

# In[15]:


X[:, 0]


# In[16]:


X[:, 1]


# `X[um_vetor]` pega as linhas da matriz. `X[:, um_vetor]` pega as colunas

# In[17]:


X[[0, 0, 1]] # observe que pego a primeira linha, indexada por 0, duas vezes


# Abaixo pego a segunda a primeira coluna

# In[18]:


X[:, [1, 0]]


# ### Indexa√ß√£o Booleana
# 
# `X[vetor_booleano]` retorna as linhas (ou colunas quando X[:, vetor_booleano]) onde o vetor √© true

# In[19]:


X[[True, False, True, False]]


# In[20]:


X[:, [False, True, True]]


# ### Reshape, Flatten e Ravel
# 
# Todo vetor ou matriz pode ser redimensionado. Observe como uma matriz abaixo de 9x8=72 elementos. Podemos redimensionar os mesmos para outros arrays de tamanho 72.

# In[21]:


X = np.random.randn(9, 8)


# Criando uma matriz de 18x4.

# In[22]:


X.reshape((18, 4))


# Ou um vetor de 72

# In[23]:


X.reshape(72)


# A chamada flatten e ravel faz a mesma coisa, criam uma vis√£o de uma dimens√£o da matriz.

# In[24]:


X.flatten()


# In[25]:


X.ravel()


# As fun√ß√µes incorporadas ao NumPy podem ser facilmente chamadas em matrizes. A maioria das fun√ß√µes s√£o aplicadas a um elemento de array (como a multiplica√ß√£o escalar). Por exemplo, se chamarmos `log()` em um array, o logaritmo ser√° obtido de cada elemento. 

# In[26]:


np.log(data)


# Mean tira a m√©dia

# In[27]:


np.mean(data)


# Algumas fun√ß√µes podem ser chamadas direto no vetor, nem todas ser√£o assim. O importante √© ler a [documenta√ß√£o](http://numpy.org) e aprender. Com um pouco de pr√°tica voc√™ vai se acostumando.

# In[28]:


data.mean()


# Abaixo temos a mediana,

# In[29]:


np.median(data) # por exemplo, n√£o existe data.median(). Faz sentido? N√£o. Mas √© assim.


# Em matrizes as fun√ß√µes operam em todos os elemntos.

# In[30]:


np.median(X)


# In[31]:


X.mean()


# In[32]:


np.log(X + 10)


# Por√©m, caso voc√™ queira a media de linhas ou colunas use `axis`. Antes, vamos ver o tamanho do vetor.

# In[33]:


X.shape


# In[34]:


np.mean(X, axis=0) # m√©dia das colunas. como temos 8 colunas, temos 8 elementos.


# In[35]:


np.mean(X, axis=0).shape


# In[36]:


np.mean(X, axis=1) # m√©dia das linhas


# In[37]:


np.mean(X, axis=1).shape


# Lembre-se que eixo 0 √© coluna. Eixo 1 √© linas.

# ### Multiplica√ß√£o de Matrizes

# Para transpor uma matriz fazemos uso de .T

# In[38]:


X.shape


# In[39]:


X.T.shape


# In[40]:


X.T


# Para multiplicar matrizes, do ponto de visto de multiplica√ß√£o matricial como definido na √°lgebra linear, fazemos uso de `@`.

# In[41]:


X @ X.T


# O uso de `*` realiza uma opera√ß√£o ponto a ponto

# In[42]:


X * X


# Observe a diferen√ßa de tamanhos

# In[43]:


(X * X).shape


# In[44]:


(X @ X.T).shape


# **Pense:** Para o nosso `X` de tamanho `(9, 8)`, qual o motivo de `X * X.T` n√£o funcionar? Qual o motivo de `X @ X` n√£o funcionar?

# ## Corre√ß√£o Autom√°tica
# 
# Nossa corre√ß√£o autom√°tica depende das fun√ß√µes abaixo. Tais fun√ß√µes comparam valores que ser√£o computados pelo seu c√≥digo com uma sa√≠da esperada. Normalmente, voc√™s n√£o fazer uso de tais fun√ß√µes em notebooks como este. Por√©m, elas s√£o chave em ambientes de testes autom√°ticos (fora do nosso escopo).
# 
# Observe como algumas fun√ß√µes comparam valores e outras comparam vetores. Al√©m do mais, temos fun√ß√µes para comparar dentro de algumas casas decimais.

# In[45]:


from numpy.testing import assert_almost_equal
from numpy.testing import assert_equal

from numpy.testing import assert_array_almost_equal
from numpy.testing import assert_array_equal


# In[46]:


# caso voc√™ mude um dos valores vamos receber um erro!
assert_array_equal(2, 2)

# caso voc√™ mude um dos valores vamos receber um erro!
assert_array_equal([1, 2], [1, 2])

# caso voc√™ mude um dos valores vamos receber um erro!
assert_almost_equal(3.1415, 3.14, 1)


# Caso voc√™ mude um dos valores abaixo vamos receber um erro! Como o abaixo.
# 
# ```
# -----------------------------------------------------------------------
# AssertionError                        Traceback (most recent call last)
# <ipython-input-10-396672d880f2> in <module>
# ----> 1 assert_equal(2, 3) # caso voc√™ mude um dos valores vamos receber um erro!
# 
# ~/miniconda3/lib/python3.7/site-packages/numpy/testing/_private/utils.py in assert_equal(actual, desired, err_msg, verbose)
#     413         # Explicitly use __eq__ for comparison, gh-2552
#     414         if not (desired == actual):
# --> 415             raise AssertionError(msg)
#     416 
#     417     except (DeprecationWarning, FutureWarning) as e:
# 
# AssertionError: 
# Items are not equal:
#  ACTUAL: 2
#  DESIRED: 3
#  ```

# √â essencial que todo seu c√≥digo execute sem erros! Portanto, antes de submeter clique em `Kernel` no menu acima. Depois clique em `Restart & Execute All.`
# 
# **Garanta que o notebook executa at√© o fim!** Isto √©, sem erros como o acima.

# ## Fun√ß√µes em Python

# Para criar uma fun√ß√£o em Python fazemos uso da palavra-chave: 
# ```python
# def
# ```
# 
# Todos nossos exerc√≠cios far√£o uso de fun√ß√µes. **Mantenha a assinatura das fun√ß√µes exatamente como requisitado, a corre√ß√£o autom√°tica depende disso.** Abaixo, temos um exempo de uma fun√ß√£o que imprime algo na tela!

# In[47]:


def print_something(txt):
    print(f'Voc√™ passou o argumento: {txt}')


# In[48]:


print_something('DCC 212')


# Podemos tamb√©m dizer o tipo do argumento, por√©m faremos pouco uso disto em ICD.

# In[49]:


def print_something(txt: str):
    print(f'Voc√™ passou o argumento: {txt}')


# In[50]:


print_something('DCC 212')


# Abaixo temos uma fun√ß√£o que soma, a soma, dois vetores

# In[51]:


def sum_of_sum_vectors(array_1, array_2):
    return (array_1 + array_2).sum()


# In[52]:


x = np.array([1, 2])
y = np.array([1, 2])


# In[53]:


sum_of_sum_vectors(x, y)


# Abaixo temos um teste, tais testes v√£o avaliar o seu c√≥digo. Nem todos est√£o aqui no notebook!

# In[54]:


assert_equal(6, sum_of_sum_vectors(x, y))


# ## Exerc√≠cio 01
# 
# Inicialmente, crie uma fun√ß√£o que recebe duas listas de num√©ros, converte as duas para um vetor numpy usando `np.array` e retorna o produto interno das duas listas. 
# 
# __Dicas:__  
# 1. Tente fazer um c√≥digo sem nenhum **for**! Ou seja, numpy permite opera√ß√µes em vetores e matrizes, onde: `np.array([1, 2]) + np.array([2, 2]) = np.array([3, 4])`.
# 
# __Fun√ß√µes:__
# 1. `np.sum(array)` soma os elementos do array. `array.sum()` tem o mesmo efeito!

# In[63]:


def inner(array_1, array_2):
    return np.sum(np.array(array_1) * np.array(array_2))


# In[64]:


x1 = np.array([2, 4, 8])
x2 = np.array([10, 100, 1000])
assert_equal(20 + 400 + 8000, inner(x1, x2))


# ## Exerc√≠cio 02
# 
# Implemente uma fun√ß√£o utilizando numpy que recebe duas matrizes, multiplica as duas e retorne o valor m√©dio das c√©lulas da multiplica√ß√£o. Por exemplo, ao multiplicar:
# 
# ```
# [1 2]
# [3 4] 
# 
# com 
# 
# [2 1]
# [1 2]
# 
# temos
# 
# [4  5 ]
# [10 11]
# 
# onde a m√©dia de [4, 5, 10, 11] √©
# 
# 7.5, sua resposta final!
# ```
# 
# 
# __Dicas:__  
# 1. Use o operador @ para multiplicar matrizes!

# In[69]:


def medmult(X_1, X_2):
    return np.mean(np.matmul(X_1, X_2))


# In[70]:


X = np.array([1, 2, 3, 4]).reshape(2, 2)
Y = np.array([2, 1, 1, 2]).reshape(2, 2)
assert_equal(7.5, medmult(X, Y))

